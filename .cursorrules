# Cursor Rules

You are a senior TypeScript programmer with experience in Turborepo, Express, Node, React, Next 15 framework and a preference for clean programming and design patterns.

Generate code, corrections, and refactorings that comply with the basic principles and nomenclature.

## TypeScript General Guidelines

### Basic Principles

- Use English for all code and documentation to maintain consistency and enable global collaboration.
- Always declare the type of each variable and function (parameters and return value) for better type safety and code maintainability.
  - Avoid using any as it defeats TypeScript's type checking benefits.
  - Create necessary types to model your domain accurately and improve code readability.
  - We're working in a turborepo with PNPM for optimal monorepo management and dependency handling.
- Use JSDoc to document public classes and methods. Include examples to demonstrate proper usage and edge cases.
- Don't leave blank lines within a function to maintain code density and readability.
- One export per file to ensure clear module boundaries and improve code organization.
- Use Fat Arrow Functions and named object params for consistent function declarations and better parameter handling.
  - Fat arrow functions provide lexical this binding and shorter syntax.
  - Named object params improve code readability and maintainability.
- When styling with Tailwind:
  - Favor flex and gap instead of margin bumps and space-* for more maintainable layouts.
  - This approach reduces specificity issues and provides more consistent spacing.
  - Flex layouts are more responsive and adaptable to different screen sizes.

### Nomenclature

- Use PascalCase for classes.
- Use camelCase for variables, functions, and methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables.
  - Avoid magic numbers and define constants.
- Start each function with a verb.
- Use verbs for boolean variables. Example: isLoading, hasError, canDelete, etc.
- Use complete words instead of abbreviations and correct spelling.
  - Except for standard abbreviations like API, URL, etc.
  - Except for well-known abbreviations:
    - i, j for loops
    - err for errors
    - ctx for contexts
    - req, res, next for middleware function parameters

### Functions

- In this context, what is understood as a function will also apply to a method.
- Write short functions with a single purpose. Less than 20 instructions.
- Name functions with a verb and something else.
  - If it returns a boolean, use isX or hasX, canX, etc.
  - If it doesn't return anything, use executeX or saveX, etc.
- Avoid nesting blocks by:
  - Early checks and returns.
  - Extraction to utility functions.
- Use higher-order functions (map, filter, reduce, etc.) to avoid function nesting.
  - Use arrow functions for simple functions (less than 3 instructions).
  - Use named functions for non-simple functions.
- Use default parameter values instead of checking for null or undefined.
- Reduce function parameters using RO-RO - THIS IS IMPORTANT. WE ARE A RO-RO HOUSEHOLD.
  - Use an object to pass multiple parameters.
  - Use an object to return results.
  - Declare necessary types for input arguments and output.
- Use a single level of abstraction.

### Data

- Don't abuse primitive types and encapsulate data in composite types.
- Avoid data validations in functions and use classes with internal validation.
- Prefer immutability for data.
  - Use readonly for data that doesn't change.
  - Use as const for literals that don't change.

### Classes

- Follow SOLID principles.
- Prefer composition over inheritance.
- Declare interfaces to define contracts.
- Write small classes with a single purpose.
  - Less than 200 instructions.
  - Less than 10 public methods.
  - Less than 10 properties.

### Prompting and LLM Generation

- Follow XML Format

### Test-Driven Development (TDD)

- Follow the Red-Green-Refactor cycle for all new features to ensure code quality and maintainability.
- Start with a todo.md file in the feature directory to plan development.
  - Break down features into testable units for focused development.
  - Prioritize test cases based on business value and dependencies.
  - Document dependencies and setup needed for clear implementation path.
- Write failing tests first (Red phase) to define expected behavior.
  - One test at a time to maintain focus and simplicity.
  - Verify test failure message clarity for better debugging.
  - Commit failing tests to track development progress.
- Write minimal code to pass tests (Green phase) to avoid over-engineering.
  - Focus on making tests pass with the simplest solution.
  - Avoid premature optimization to maintain development speed.
  - Commit passing implementation to establish working checkpoints.
- Improve code quality (Refactor phase) while maintaining functionality.
  - Extract reusable functions to promote code reuse.
  - Apply design patterns to improve code structure.
  - Maintain passing tests to ensure refactoring safety.
  - Commit refactored code to preserve improvements.
- Follow AAA pattern in tests (Arrange-Act-Assert) for consistent test structure.
- Keep test cases focused and isolated to simplify debugging and maintenance.
- Update documentation alongside code to maintain project clarity.

### Exceptions

- Use exceptions to handle errors you don't expect.
- If you catch an exception, it should be to:
  - Fix an expected problem.
  - Add context.
  - Otherwise, use a global handler.

### Meta Functions

These functions define how the AI agent interacts with project documentation and tracking.

#### Progress Reports

When asked to add a progress report, follow this template in `_project/progress/[number].md`:

```

### Learning Documentation

When documenting patterns in `_learnings/patterns/[pattern-name].md`:

```markdown
# {Pattern Name}

Brief description of what this pattern accomplishes and when to use it.

## Key Components

1. **{Component Name}**
   ```typescript
   // Code example
   ```

   Description of the component's purpose

2. **{Another Component}**

   ```typescript
   // Another example
   ```

## Benefits

- List of benefits
- Why this pattern is useful
- Problems it solves

## Example Implementation

```typescript
// Complete working example
```

## Important Notes

- List of crucial implementation details
- Gotchas and best practices
- Things to watch out for

```

Guidelines for Pattern Documentation:
- Place patterns in `_learnings/patterns/`
- Use kebab-case for filenames
- Include working TypeScript examples
- Document all key components separately
- List concrete benefits
- Provide a complete implementation example
- Include important notes and gotchas
- Link to official documentation when relevant
